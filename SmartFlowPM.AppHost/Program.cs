using System.Diagnostics;
using Microsoft.Extensions.Hosting;

var builder = DistributedApplication.CreateBuilder(args);

// Add the API project with comprehensive observability
// The API will use its own connection string from appsettings.Development.json
var apiService = builder.AddProject<Projects.GenAI_SmartFlowPM_WebAPI>("api")
    .WithEnvironment("ASPNETCORE_ENVIRONMENT", builder.Environment.EnvironmentName);

// Clean up any existing Next.js processes and generate configuration
CleanupNextjsProcesses();
GenerateNextjsConfig();

// Add the Next.js frontend with environment configuration and named HTTP client setup
var isDevelopment = builder.Environment.EnvironmentName == "Development";
var frontend = builder.AddNpmApp("frontend", "../src/Web/GenAI.SmartFlowPM.UI", isDevelopment ? "dev" : "start")
    .WithReference(apiService)
    .WithExternalHttpEndpoints()
    .WithEnvironment("NODE_ENV", isDevelopment ? "development" : "production")
    .WithEnvironment("PORT", "3001")
    .WithEnvironment("NEXT_PUBLIC_API_URL", "https://localhost:7149/api")
    .WithEnvironment("NEXT_PUBLIC_API_URL_HTTP", "http://localhost:5052/api")
    .WithEnvironment("NEXT_PUBLIC_ENVIRONMENT", isDevelopment ? "development" : "production");

// Add Docker publishing for production
if (!isDevelopment)
{
    frontend.PublishAsDockerFile();
}

var app = builder.Build();

app.Run();

static void GenerateNextjsConfig()
{
    try
    {
        var configPath = Path.Combine("..", "src", "Web", "GenAI.SmartFlowPM.UI", "public", "config.js");
        var configDir = Path.GetDirectoryName(configPath);

        if (configDir != null && !Directory.Exists(configDir))
        {
            Directory.CreateDirectory(configDir);
        }

        // Use the fixed API URL from launchSettings.json with health check endpoints
        var apiUrl = "https://localhost:7149/api";
        var apiUrlHttp = "http://localhost:5052/api";

        var configContent = $@"// This file is dynamically generated by Aspire
        window.APP_CONFIG = {{
            API_URL: '{apiUrl}',
            API_URL_HTTP: '{apiUrlHttp}',
            HEALTH_CHECK_URL: 'https://localhost:7149/health',
            HEALTH_CHECK_URL_HTTP: 'http://localhost:5052/health',
            ENVIRONMENT: 'development',
            RETRY_ATTEMPTS: 3,
            TIMEOUT_MS: 30000,
            ENABLE_TRACING: true
        }};";

        File.WriteAllText(configPath, configContent);
        Console.WriteLine($"Generated Next.js config with API URL: {apiUrl}");
        Console.WriteLine($"Health check endpoints configured for monitoring");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Failed to generate Next.js config: {ex.Message}");
    }
}

static void CleanupNextjsProcesses()
{
    try
    {
        Console.WriteLine("Cleaning up any existing Next.js processes...");

        // Kill processes using ports 3000, 3001, 3002
        var ports = new[] { 3000, 3001, 3002 };
        foreach (var port in ports)
        {
            try
            {
                var processInfo = new ProcessStartInfo
                {
                    FileName = "netstat",
                    Arguments = "-ano",
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                using var process = Process.Start(processInfo);
                if (process != null)
                {
                    var output = process.StandardOutput.ReadToEnd();
                    process.WaitForExit();

                    var lines = output.Split('\n');
                    foreach (var line in lines)
                    {
                        if (line.Contains($":{port}") && line.Contains("LISTENING"))
                        {
                            var parts = line.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                            if (parts.Length > 0 && int.TryParse(parts[^1], out var pid))
                            {
                                try
                                {
                                    var killProcess = Process.GetProcessById(pid);
                                    killProcess.Kill();
                                    Console.WriteLine($"Killed process {pid} using port {port}");
                                }
                                catch
                                {
                                    // Process might already be gone
                                }
                            }
                        }
                    }
                }
            }
            catch
            {
                // Continue if we can't clean up a specific port
            }
        }

        Console.WriteLine("Cleanup completed.");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Failed to cleanup Next.js processes: {ex.Message}");
    }
}
